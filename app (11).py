# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O8kA1Li_dx4ugwBwR_NiN5WgWMALSNaj
"""

!pip install  streamlit
import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
from sklearn.cluster import KMeans
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler



# app.py — FINAL VERSION THAT WORKS WITH ANY DATA (2025)
!pip install streamlit
import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler

google_df_preloaded = pd.read_csv('/content/google_ads-sheet1-sourcetable (1).csv')
linkedin_df_preloaded = pd.read_csv('/content/linked_in_campaigns-sheet1-sourcetable (1).csv')
meta_df_preloaded = pd.read_csv('/content/meta_ads_campaigns-sheet1-sourcetable.csv')

st.set_page_config(page_title="Ad Profit AI", layout="wide")
st.title("Ad Profit AI – Instant Money Leak Detector")
st.markdown("**Upload Google Ads, LinkedIn, Meta CSVs → See exactly where your profit is hiding**")

# FILE UPLOADER (commented out for Colab execution - using pre-loaded data instead)
# uploaded_files = st.file_uploader(
#     "Upload your ad CSV files (Google, LinkedIn, Meta)",
#     type=["csv"], accept_multiple_files=True
# )

# if not uploaded_files:
#     st.info("Please upload at least one CSV file to start analysis")
#     st.stop()

# # READ ALL UPLOADED FILES
# dfs = [pd.read_csv(f) for f in uploaded_files]

# AUTO DETECT PLATFORM FROM FILENAME (modified to use pre-loaded dataframes)
# Instead of detecting from uploaded files, we directly use the pre-loaded ones
google = google_df_preloaded.copy() if google_df_preloaded is not None else None
linkedin = linkedin_df_preloaded.copy() if linkedin_df_preloaded is not None else None
meta = meta_df_preloaded.copy() if meta_df_preloaded is not None else None

# SUPER ROBUST CLEANING FUNCTION (handles ANY column name)
def clean_money_column(df, possible_names):
    for col in possible_names:
        if col in df.columns:
            df[col] = df[col].astype(str).str.replace(r'[\$,]', '', regex=True)
            df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)
            return df[col]
    return pd.Series(0, index=df.index)

# PREPARE EACH PLATFORM
final_dfs = []

if google is not None and not google.empty:
    g = google.copy()
    g['Spend'] = clean_money_column(g, ['Cost', 'Amount spent', 'Spend', 'Total Cost'])
    g['Conversions'] = g.get('Conversions', 0)
    g['Revenue'] = 0
    g['Platform'] = 'Google Ads'
    final_dfs.append(g)

if linkedin is not None and not linkedin.empty:
    l = linkedin.copy()
    l['Spend'] = clean_money_column(l, ['Total Spent (USD)', 'Amount spent', 'Spend', 'Cost'])
    l['Conversions'] = l.get('Leads', l.get('Conversions', 0))
    l['Revenue'] = 0
    l['Platform'] = 'LinkedIn'
    final_dfs.append(l)

if meta is not None and not meta.empty:
    m = meta.copy()
    m['Spend'] = clean_money_column(m, ['Amount spent', 'Spend', 'Cost'])
    m['Revenue'] = clean_money_column(m, ['Purchase value', 'Revenue', 'Value', 'Sales'])
    m['Conversions'] = m.get('Purchases', m.get('Conversions', 0))
    m['Platform'] = 'Meta'
    final_dfs.append(m)

# COMBINE ALL
if not final_dfs:
    st.error("No valid ad data found. Check file names or columns.")
    # In a Colab environment, st.stop() doesn't actually stop the script
    # We'll raise an error or return to prevent further execution if no data
    raise ValueError("No valid ad data found to concatenate.")

df = pd.concat(final_dfs, ignore_index=True)

# FINAL METRICS
df['Spend'] = pd.to_numeric(df['Spend'], errors='coerce').fillna(0)
df['Revenue'] = pd.to_numeric(df['Revenue'], errors='coerce').fillna(0)
df['Conversions'] = pd.to_numeric(df['Conversions'], errors='coerce').fillna(0)
df['ROAS'] = np.where(df['Spend'] > 0, df['Revenue'] / df['Spend'], 0)

# MACHINE LEARNING
features = ['Spend', 'Conversions', 'Revenue', 'ROAS']
X = df[features].fillna(0)
X_scaled = StandardScaler().fit_transform(X)
df['Segment'] = KMeans(n_clusters=4, random_state=42, n_init=10).fit_predict(X_scaled)

# DASHBOARD
col1, col2, col3, col4 = st.columns(4)
col1.metric("Total Spend", f"${df['Spend'].sum():,.0f}")
col2.metric("Revenue", f"${df['Revenue'].sum():,.0f}")
col3.metric("Profit", f"${df['Revenue'].sum() - df['Spend'].sum():,.0f}")
col4.metric("Avg ROAS", f"{df['ROAS'].mean():.2f}x")

# BLEEDING CAMPAIGNS
bleeding = df[(df['Spend'] > 200) & (df['Conversions'] == 0) & (df['Revenue'] == 0)]
if len(bleeding) > 0:
    st.error(f"URGENT: {len(bleeding)} campaigns wasting ${bleeding['Spend'].sum():,.0f} → PAUSE NOW!")

# WINNING CAMPAIGNS
winning = df[df['ROAS'] > 3].sort_values('ROAS', ascending=False).head(5)
if len(winning) > 0:
    st.success(f"WINNERS: {len(winning)} campaigns with >3x ROAS → SCALE THESE!")

# CHART
campaign_col = next((col for col in ['Campaign Name', 'Campaign', 'Campaign name'] if col in df.columns), 'Platform')
fig = px.scatter(
    df, x="Spend", y="Revenue", color="Platform", size="ROAS",
    hover_data=[campaign_col] if campaign_col != 'Platform' else [],
    title="Where Your Ad Money Actually Makes Profit"
)
st.plotly_chart(fig, use_container_width=True)

st.success("Your Ad Profit AI is LIVE and unbreakable!")
st.balloons()